{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}
module Crud where

import Prelude
import Model
import Yesod
--import Yesod.Form
import Data.Text (Text)
--import Text.Shakespeare.I18N
import Control.Applicative
import Data.Data

import Language.Haskell.TH
import Data.Char (toUpper)


class EntityForm a where
    toAForm :: (MonadHandler m, RenderMessage (HandlerSite m) FormMessage) =>
        Maybe a -> AForm m a

fieldForm :: (RenderMessage site FormMessage, MonadHandler m,
           HandlerSite m ~ site, ToField t,
           EntityFieldsForm a, EntityFieldLabeled a) =>
    EntityField a t -> Maybe a -> AForm m t
fieldForm field entityMay = areq toField
    (fieldSettingsLabel $ fieldLabel field)
    (fieldValue field <$> entityMay)


class EntityFieldsForm a where
    fieldValue :: EntityField a t -> a -> t

-- FIXME: should be generated by TH
#if 0
instance EntityFieldsForm Faq where
    fieldValue FaqId = undefined -- FIXME
    fieldValue FaqName = faqName
    fieldValue FaqContent = faqContent
    fieldValue FaqOrder = faqOrder
#endif


class EntityFieldLabeled a where
    -- FIXME: generalize to RenderMessage site msg
    fieldLabel :: EntityField a t -> Text

-- FIXME: user should generate it with TH or easily overriden
instance EntityFieldLabeled Faq where
    fieldLabel FaqId = "Id" :: Text
    fieldLabel FaqName = "Name" :: Text
    fieldLabel FaqContent = "Content" :: Text
    fieldLabel FaqOrder = "Order" :: Text

class ToField a where
    toField :: Monad m => RenderMessage (HandlerSite m) FormMessage =>
        Field m a

instance ToField Text where
    toField = textField

instance ToField Int where
    toField = intField


derivePersistForm :: String -> Q [Dec]
derivePersistForm s = do
    let dcs = concat $ map constrFields . dataTypeConstrs . dataTypeOf $
            (undefined :: Faq)
    let iFF typ = InstanceD [] (ConT ''EntityFieldsForm `AppT` typ)
    return
        [ iFF (ConT $ mkName s)
            [ FunD 'fieldValue $
                (flip map) dcs $ \acc ->
                    let field [] = []
                        field (x:xs) = toUpper x : xs
                        aName = mkName acc
                        fName = mkName $ field acc
                    in Clause [ConP fName []] (NormalB $ VarE aName) []
            ]
        ]
